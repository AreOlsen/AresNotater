<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Quicksort. [[Big theta]]
Likt som [[Mergesort]], bruker også quicksort [[Divide and Conquer.]] strukturen så den er også ein rekursiv algoritme. Men måten quicksort bruker divide and conquer er litt forskjellig i fra mergesort."><title>Ares Notater</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://quartz.jzhao.xyz//icon.png><link href=https://quartz.jzhao.xyz/styles.706bb6073ba85d26809f9096dae23a6b.min.css rel=stylesheet><link href=https://quartz.jzhao.xyz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://quartz.jzhao.xyz/js/darkmode.63d6a3e095d0bd2b935b62adec9dc11b.min.js></script>
<script src=https://quartz.jzhao.xyz/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://quartz.jzhao.xyz/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://quartz.jzhao.xyz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://quartz.jzhao.xyz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://quartz.jzhao.xyz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://quartz.jzhao.xyz/",fetchData=Promise.all([fetch("https://quartz.jzhao.xyz/indices/linkIndex.3650a1fb8b1d9417b70ace49f74a464d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://quartz.jzhao.xyz/indices/contentIndex.6398ac61128b80f1dbe5df81a4bc73ea.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://quartz.jzhao.xyz",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://quartz.jzhao.xyz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/quartz.jzhao.xyz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://quartz.jzhao.xyz/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://quartz.jzhao.xyz/>Ares Notater</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Dec 3, 2022
<a href=https://github.com/SimonGoBrrr/AresNotater.github.io/notes/IT./Sorterings%20algoritmer./Quicksort..md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#linear-time-partiotioning>Linear-time partiotioning.</a></li></ol><ol><li><a href=#verste-case-sceneario-running-time>Verste-case sceneario running time.</a></li><li><a href=#beste-case-sceneario-running-time>Beste-case sceneario running time.</a></li><li><a href=#gjennomsnittleg-case-scenario-running-time>Gjennomsnittleg-case scenario running-time.</a></li></ol></nav></details></aside><a href=#quicksort><h1 id=quicksort><span class=hanchor arialabel=Anchor># </span>Quicksort.</h1></a><p><a class="internal-link broken">Big theta</a></p><p>Likt som <a class="internal-link broken">Mergesort</a>, bruker også quicksort <a class="internal-link broken">Divide and Conquer.</a> strukturen så den er også ein rekursiv algoritme. Men måten quicksort bruker divide and conquer er litt forskjellig i fra mergesort. I mergesort bruker divide steget så vidt noko i det heile, og alt det vanskelige skjer i combine steget. Quicksort derimot er det omvendte, all det vanskelige arbeidet skjer i divide steget. Honestly combine stegt i quicksort gjer avsolutt ingenting, no like seriously.</p><p>Quicksort har norke nøkkeldifferanser i frå mergeSort. Quicksort jobber in place. Og dens worst-case running time er like gale som <a class="internal-link broken">Selection sort.</a> og <a class="internal-link broken">Insertion sort.</a> $\theta(n^2)$. Men dens gjennomsnittlege-case running time er like god som mergeSort sin $\theta(n\times \log_2(n))$.</p><p>Så kvifor tenker vi på quicksort når vi har eit like godt alternativ mergeSort?
Dette er fordi den konstante faktoren som er gjømt i <a class="internal-link broken">Big theta</a> notasjonen for quicksort er ganske god.. I praktisk pleier quicksort å gjøre det betre enn mergeSort og den gjer det mykje betre enn selection sort og insertion sort.</p><p>Her kan vi sjå korleis quicksort bruker divide and conquer strukturen. Likt som med mergeSort tenk på ein subarray $array[p..r]$, der den originale subarrayen er $array[0..n-1]$.</p><ol><li>Divide ved å velge eit tilfeldig element i subarrayen $array[p..r]$. Kall dette elementet vår pivot point.<ol><li>Rearranger alle elementene i $array[p..r]$ slik at alle elementene i $array[p..r]$ er mindre eller lik pivotpointen til venstre for den, og alle som er høgere til høgre for den. Dette blir kalt for <strong>partitioning</strong>. På dette punktet er det ikkje viktig kva rekkefølge elementene til venstre av pivotpointet har til felles med kvarandre, eller likt til høgre for pivot pointet. Vi bryr oss berre om kvart element er på rett side av pivotpointet.</li><li>Vi oftast pleier å velge vårt pivotpoint som det siste elementet i subarrayen.</li></ol></li><li>Conquer, ved å rekursivt sortere subarrayen sin $array[p..q-1]$ (Alle elementer til venstre for pivotpointet, som må vere mindre eller lik pivotpointet) og $array[q+1..r]$ (Alle elementer til høgre for pivot pointet, som må vere større eller lik pivotpointet).</li><li>Kombiner ved å gjere ingenting, fordi vi har allereie sortert den i gjennom divide og conquer steget. Combine steget i quicksort combine ingenting!</li></ol><p>Base-casen er når subararrayen er av størrelse mindre enn to elementer, akkurat som i mergeSort. I merge, ser du aldri ein subarray med 0 elementer, men det kan du gjere i quicksort dersom alle andre elementer er entens til venstre eller høgre for pivotpointet når det sortert.</p><p>Slik utvikler quicksort seg:
<img src=https://cdn.kastatic.org/ka-perseus-images/9876d4dc59e01a4742860ae1831c20f654ed7959.png width=auto alt></p><p>Vi velger eit pivotpoint, vi rearrangerer, vi velger eit nytt pivot point, vi rearrangerer, repiter til vi har ein subarray av element størrelse lavere enn 2. Sorter denne, det er jo berre å sjekke kass av dei to som er størst og plassere riktig.</p><a href=#linear-time-partiotioning><h2 id=linear-time-partiotioning><span class=hanchor arialabel=Anchor># </span>Linear-time partiotioning.</h2></a><p>Det virkelige arbeidet av quicksort skjer i løpet av divider steget, som partione $array[p..r]$ rundt eit pivot point dratt i frå subarrayen. Likevel vi kan velge kva enn som helst element i subarrayen som pivot pointet, er det enklest å partione viss vi velger det høgste index elementet av subarray $array[p..r]$.</p><p>Etter at vi har vårt pivot point kan vi partione subarrayen ved å gå gjennom den frå venstre til høgre og samenligne kvart element med pivoten, har har to indices $q$ og $j$ in i subarrayen som dividerer den opp i $4$ grupper. Vi kan bruke variabeln $q$ fordi indexen vil eventuellt vere på vårt pivot point. Vi kan bruke $j$ fordi det er ein teller variabel og variabelen blir kastet vekk når vi er ferdig.</p><ul><li>Alle elementer i $array[p..q-1]$ er gruppe &ldquo;L&rdquo;, som består av elementer kjent til å vere mindre eller lik til pivoten.</li><li>Alle elementer i subarrayen $array[q..j-1]$ er gruppe &ldquo;G&rdquo; som består av elementer kjent til å vere større enn pivoten.</li><li>Elementer i subarray $array[j..r-1]$ er kjent som gruppe &ldquo;U&rdquo;, og består av elementer som sitt forhold til pivtoen er ukjent, fordi dei har ikkje enda blitt compared.</li><li>$array[r]$ er gruppe &ldquo;P&rdquo;, pivot pointet.</li></ul><p>Originalt er både $q$ og $j$ lik som $p$. Ved kvart steg, samanliknar vi $array[j]$, den mest venstre elementet i gruppe &ldquo;U&rdquo; med pivoten. Viss $array[j]$ er større enn pivoten så $j++$, slik at linjen som dividerer gruppe &ldquo;G&rdquo; og gruppe &ldquo;U&rdquo; går ein posisjon over til høgre.
<img src=https://cdn.kastatic.org/ka-perseus-images/557d3afb93f7ba9abb3a9e845113fcf9ce1e56d8.png width=auto alt></p><p>Når vi kommer til pivoten så er gruppe &ldquo;U&rdquo; tom. Vi deretter swapper pivoten med den mest venstre elementet i gruppe &ldquo;G&rdquo;: swap $array[r]$ med $array[q]$. Dette plasserer pivoten mellom gruppene &ldquo;L&rdquo; og &ldquo;G&rdquo; og gjer den rette tingen til og med viss gruppe &ldquo;L&rdquo; eller gruppe &ldquo;G&rdquo; er tom.</p><p>Denne &ldquo;partition&rdquo; funksjonen som implementerer denne ideen returner og index $q$ der den endte opp med å plassere pivoten, slik at $quicksort$ funksjonen, som blir kalt, veit kor partitionsene er.</p><p>Her er dei første stegene i partione subarray $[12,7,14,9,10,11]$ i $array[4..9]$</p><p><img src=https://cdn.kastatic.org/ka-perseus-images/53692155715c9f26ec927cb2d40e70ce6c460e86.png width=auto alt></p><p>Å partionene ein subarray med $n$ element vil ta $\theta(n)$ tid. Kvart element $array[j]$ er compared ein gang med pivoten. $array[j]$ kanskje eller kanskje ikke blir swapper med $array[q]$, og $q$ kanskje eller kanskje ikkje blir inkrementert, og $j$ blir alltid inkrementert. Den totale nummeret av linjer executer per element av subarrayen er konstant. Siden subarrayen har $n$ vil den totale partition tiden vere $\theta(n)$: linear-time partioning.</p><a href=#analyse-av-quicksort><h1 id=analyse-av-quicksort><span class=hanchor arialabel=Anchor># </span>Analyse av quicksort.</h1></a><p>Satan fuck deg quicksort. 🤯.</p><p>Quicksort sin verse case sceneario og gjennomsnittleg scenario er forskjellig på grunn av metoden vi finner vårt pivot-point som lar oss redusere tidsbruken ganske mykje.
Viss vi er ganske uheldig og partition størrelse er jævlig ubalansert, i vertste tilfelle der den eine er $0$ og den andre $n-1$ , alle utanom pivotpointet, så vil det vere <a class="internal-link broken">rekurisve tilkallinger på størrelser av n-1 og 0.</a>. Likt som i <a class="internal-link broken">Mergesort</a> er denne tidne det samme som $\theta(n)$ på ein array av størrelse $n$. I mergesort er det tiden for meging, men i quicksort er det <strong>berre</strong> tiden for partitioning.</p><a href=#verste-case-sceneario-running-time><h2 id=verste-case-sceneario-running-time><span class=hanchor arialabel=Anchor># </span>Verste-case sceneario running time.</h2></a><p>Når quicksort alltid har den mest ubalanserte partitionene mogleg så er den originale tilkallingen $cn$ tid for ein konstant av $c$, og der er $n-1$ rekurisve tilkallinger, den første vil dermed vere $c(n-1)$ den neste $c(n-2)$ …… til det er $c(1)$. Slik vil denne subproblem grafen sjå ut.
<img src=https://cdn.kastatic.org/ka-perseus-images/7da2ac32779bef669a6f05decb62f219a9132158.png width=auto alt></p><p>Når vi tar og adderer alle dei ulike running-timene vil det sjå slik ut:
$cn+c(n-1)+c(n-2)……+2c=c(n+(n-1)+(n-2)+(n-3)……)=c((n+1)(\frac{n}{2})-1)$.
Den siste linjen $1+2+3…………+n$ er ein aritmetikk serier, og som vi såg når vi analyserte <a class="internal-link broken">Selection sort.</a> (Vi subtraherer 1 fordi for quicksort, starter summasjonen på 2, og ikkje 1). Vi har nokre lavere order termer og konstante koeffisienter, men når vi bruker <a class="internal-link broken">Big theta</a> notasjon så ignorer vi dem fordi dei er konstante verdier og lavere termer. I <a class="internal-link broken">Big theta</a> notasjon er quicksort sin verste kjøre tid $\theta(n^2)$.</p><a href=#beste-case-sceneario-running-time><h2 id=beste-case-sceneario-running-time><span class=hanchor arialabel=Anchor># </span>Beste-case sceneario running time.</h2></a><p>Quicksort sin beste case skjer når partionene er så gjevnt som mogleg, der deirast sider er entens like eller med ein distanse av 1 i størrelse av kvarandre. Casen med ingen forskjell i forskjell skjer når subarrayen har eit oddetall nummer av elementer og pivoten er rett i midten etter partionering, og kvart partition har $\huge \frac{n-1}{2}$ elementer. Den andre casen, skjer viss subarrayen har eit partall nummer av elementer og pivoten den eine siden/partionen har $\huge \frac{n}{2}$ elementer, mens den andre har $\huge \frac{n}{2}-1$ elementer. I kvar av disse casene har partionen på det meste $\huge \frac{n}{2}$ elementer, og dens tre/graf av subproblemene sine størrelse ser meir ut som treet for subproblemer i <a class="internal-link broken">Mergesort</a>, med dens partionerings tider liknande til merging tidene:
<img src=https://cdn.kastatic.org/ka-perseus-images/21cd0d70813845d67fbb11496458214f90ad7cb8.png width=auto alt></p><p>Vi bruker <a class="internal-link broken">Big theta</a> notasjon og får det samme resultatet som for mergesort $\theta(n\times \log_2(n))$.</p><a href=#gjennomsnittleg-case-scenario-running-time><h2 id=gjennomsnittleg-case-scenario-running-time><span class=hanchor arialabel=Anchor># </span>Gjennomsnittleg-case scenario running-time.</h2></a><p>For å vise at den gjennomsnittlege running timen er òg $\theta(n\times \log_2(n))$ krever det faktisk nokre ganske avansert matematikk så vi går ikkje der. Men vi kan forstå litt betre korleis denne algoritmen sin generelle kjøre tid er dersom vi ser på nokre ulike dømer.</p><p>Først la oss forestille oss at vi ikkje alltid får heilt perfekte balanserte partitionser, vi får til dømes på det verste ein split av $3$ til $1$. Det er betyr den eine siden får $\frac{3}{4}\times n$ elementer, og den andre $\frac{1}{4} \times n$ elementer. (Vi ignorer pivot pointet her for å holde matte ren, men den gjer at vi ikkje får egentelig ein perfekt 3 til 1 split). Da vil treet av subproblemer og partition tidene se slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/130b2d2a1fe897253def054f4c3aa7bd94cb6cf2.png width=auto alt></p><p>Venstre childen av ein node representerer eit subproblem av størrelse $\frac{1}{4}$ av forrige, og childen til høgre viser $\frac{3}{4}$ av forrige. Viss vi følger venstre sidene vil vi raskt minske ned til basecasen av $1$ fordi vi har mykje mindre elementer per iterasjon, mens derimot viss vi følger berre til høgre vil vi mykje saktere komme til basecasen av $1$. Som figuren viser etter $\log_4(n)$ leveler kjemer vi ned til størrelsen av $1$ viss vi følger til venstre. Det er enklest å forestille seg kvifor $\log_4(n)$ viss vi starter med $1$ og går opp med $4\times$ om gangen til vi når $n$. Så i andre ord spør vi kva verdi av $x$ vi får $4^x=n$, og svaret er jo da sjølvsagt $\log_4(n)$. Derimot når vi går nedover til høgre kvar iterasjon vil svaret vere $\log_\frac{4}{3}(n)$ til vi kommer ned til basecasen av $1$. For å førestille seg kvifor akkurat $\log_\frac{4}{3}(n)$ er det lett å tenke at kvart barn er $\frac{3}{4}$ av den øvre noden sin størrelse, kvar øvre node er dermed $\frac{4}{3}$ av barnets størrelse. Viss vi dermed starter med ein basecase av $1$ og multiplserer med $\frac{4}{3}$ til vi når $n$ så har vi multiplisert $\log_\frac{4}{3}(n)$ ganger.</p><p>Den verste runningtimen av $\log_4(n)$ og $\log_\frac{4}{3}(n)$ er $\log_\frac{4}{3}(n)$ så vi fokuserer berre på er $\log_\frac{4}{3}(n)$.For kvart av dei første $\log_4(n)$ nivåene er det $n$ elementer (inkludert pivotpointer som i realiteten ikkje blir partionet.) og så den totale partition tiden er for kvar av disse nivåene berre $cn$ for ein konstant av $c$. Og dei siste nivåene har mindre enn $n$ noder og så for kvar av disse levelene er det på det meste $cn$ runningtime. Til sammen er det $\log_\frac{4}{3}(n)$ eveler, og så den totale partition tiden er $O(n \times \log_\frac{4}{3}(n))$.</p><p>Og det er eit matematisk bevis som nemner at $\log_a(n)=\frac{\log_b(n)}{\log_b(a)}$., som tyder at vi berre har ein konstant faktor mellom dei ulike tallene og vi kan egentelig berre bestemme kva enn som helst base vi ønsker å ha når vi noterer ned runningtimen. Så vi pleier å bruke $2$ for basen. Dermed er quicksort sin running time $O(\log_2(n))$, likevel vi faktisk har ein høgere konstant faktor som er høgere enn den beste case running timen.</p><p>Kor ofte vi burde forvente å see ein split som er $3$ til $1$ eller betre? Det kjemer heilt ann på korleis vi velger våre pivot-points. Viss vi forestiller oss at pivotpintenhar ein like stor sjanse for å lande på kva enn som helst index av ein $n$ elementer liste. Da må vi pivotpointen lande i midten av arrayen for å oppnå ein split som er $3$ til $1$ eller betre.
<img src=https://cdn.kastatic.org/ka-perseus-images/a77e296baf334b577328a5f15ab294a652ad6b96.png width=auto alt></p><p>Så viss pivot-pointen har ein like stor sjanse for å lande kor enn som helst i arrayen etter partitioning er det ein $50%$ sjanse for at vi får på det verste ein split av $3$ til $1$.</p><p>Viss vi tar eit anna døme og ser på dømet der vi får ein alternerende split av $3$ til $1$ og den verste case scenario, og vi tenker på ein node i eit tre med $k$ elementer i dens subarray. Da vil treet sjå slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/1f6a230039af38419453096c58bfd3ab5ac77b0f.png width=auto alt></p><p>I staden for å sjå slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/656ca0d8ab950299dcc2800e6b2a52cc7ea6ffd5.png width=auto alt></p><p>Dermed viss vi får den verste case splitten halvparten av tiden og ein split som $3$ til $1$ halvparten av tiden vil runningtimen vere dobbel så stor av det å få ein runningtime av $3$ til $1$ kvar gang. Igjen så er dette berre ein konstant faktor som blir absorbert inn i <a class="internal-link broken">Big O</a> notasjonen, dermed er òg running timen i denne scenarioet $O(n\times \log_2(n))$.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://quartz.jzhao.xyz/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Are Olsen using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://quartz.jzhao.xyz/>Home</a></li><li><a href=https://simongobrrr.github.io>Are's Homepage</a></li><li><a href=https://github.com/SimonGoBrrr>Github</a></li></ul></footer></div></div></body></html>