<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Quicksort. [[Big theta]]
Likt som [[Mergesort]], bruker ogs√• quicksort [[Divide and Conquer.]] strukturen s√• den er ogs√• ein rekursiv algoritme. Men m√•ten quicksort bruker divide and conquer er litt forskjellig i fra mergesort."><title>Ares Notater</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://quartz.jzhao.xyz//icon.png><link href=https://quartz.jzhao.xyz/styles.706bb6073ba85d26809f9096dae23a6b.min.css rel=stylesheet><link href=https://quartz.jzhao.xyz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://quartz.jzhao.xyz/js/darkmode.63d6a3e095d0bd2b935b62adec9dc11b.min.js></script>
<script src=https://quartz.jzhao.xyz/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://quartz.jzhao.xyz/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://quartz.jzhao.xyz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://quartz.jzhao.xyz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://quartz.jzhao.xyz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://quartz.jzhao.xyz/",fetchData=Promise.all([fetch("https://quartz.jzhao.xyz/indices/linkIndex.3650a1fb8b1d9417b70ace49f74a464d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://quartz.jzhao.xyz/indices/contentIndex.6398ac61128b80f1dbe5df81a4bc73ea.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://quartz.jzhao.xyz",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://quartz.jzhao.xyz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'‚Äô':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/quartz.jzhao.xyz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://quartz.jzhao.xyz/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://quartz.jzhao.xyz/>Ares Notater</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Dec 3, 2022
<a href=https://github.com/SimonGoBrrr/AresNotater.github.io/notes/IT./Sorterings%20algoritmer./Quicksort..md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#linear-time-partiotioning>Linear-time partiotioning.</a></li></ol><ol><li><a href=#verste-case-sceneario-running-time>Verste-case sceneario running time.</a></li><li><a href=#beste-case-sceneario-running-time>Beste-case sceneario running time.</a></li><li><a href=#gjennomsnittleg-case-scenario-running-time>Gjennomsnittleg-case scenario running-time.</a></li></ol></nav></details></aside><a href=#quicksort><h1 id=quicksort><span class=hanchor arialabel=Anchor># </span>Quicksort.</h1></a><p><a class="internal-link broken">Big theta</a></p><p>Likt som <a class="internal-link broken">Mergesort</a>, bruker ogs√• quicksort <a class="internal-link broken">Divide and Conquer.</a> strukturen s√• den er ogs√• ein rekursiv algoritme. Men m√•ten quicksort bruker divide and conquer er litt forskjellig i fra mergesort. I mergesort bruker divide steget s√• vidt noko i det heile, og alt det vanskelige skjer i combine steget. Quicksort derimot er det omvendte, all det vanskelige arbeidet skjer i divide steget. Honestly combine stegt i quicksort gjer avsolutt ingenting, no like seriously.</p><p>Quicksort har norke n√∏kkeldifferanser i fr√• mergeSort. Quicksort jobber in place. Og dens worst-case running time er like gale som <a class="internal-link broken">Selection sort.</a> og <a class="internal-link broken">Insertion sort.</a> $\theta(n^2)$. Men dens gjennomsnittlege-case running time er like god som mergeSort sin $\theta(n\times \log_2(n))$.</p><p>S√• kvifor tenker vi p√• quicksort n√•r vi har eit like godt alternativ mergeSort?
Dette er fordi den konstante faktoren som er gj√∏mt i <a class="internal-link broken">Big theta</a> notasjonen for quicksort er ganske god.. I praktisk pleier quicksort √• gj√∏re det betre enn mergeSort og den gjer det mykje betre enn selection sort og insertion sort.</p><p>Her kan vi sj√• korleis quicksort bruker divide and conquer strukturen. Likt som med mergeSort tenk p√• ein subarray $array[p..r]$, der den originale subarrayen er $array[0..n-1]$.</p><ol><li>Divide ved √• velge eit tilfeldig element i subarrayen $array[p..r]$. Kall dette elementet v√•r pivot point.<ol><li>Rearranger alle elementene i $array[p..r]$ slik at alle elementene i $array[p..r]$ er mindre eller lik pivotpointen til venstre for den, og alle som er h√∏gere til h√∏gre for den. Dette blir kalt for <strong>partitioning</strong>. P√• dette punktet er det ikkje viktig kva rekkef√∏lge elementene til venstre av pivotpointet har til felles med kvarandre, eller likt til h√∏gre for pivot pointet. Vi bryr oss berre om kvart element er p√• rett side av pivotpointet.</li><li>Vi oftast pleier √• velge v√•rt pivotpoint som det siste elementet i subarrayen.</li></ol></li><li>Conquer, ved √• rekursivt sortere subarrayen sin $array[p..q-1]$ (Alle elementer til venstre for pivotpointet, som m√• vere mindre eller lik pivotpointet) og $array[q+1..r]$ (Alle elementer til h√∏gre for pivot pointet, som m√• vere st√∏rre eller lik pivotpointet).</li><li>Kombiner ved √• gjere ingenting, fordi vi har allereie sortert den i gjennom divide og conquer steget. Combine steget i quicksort combine ingenting!</li></ol><p>Base-casen er n√•r subararrayen er av st√∏rrelse mindre enn to elementer, akkurat som i mergeSort. I merge, ser du aldri ein subarray med 0 elementer, men det kan du gjere i quicksort dersom alle andre elementer er entens til venstre eller h√∏gre for pivotpointet n√•r det sortert.</p><p>Slik utvikler quicksort seg:
<img src=https://cdn.kastatic.org/ka-perseus-images/9876d4dc59e01a4742860ae1831c20f654ed7959.png width=auto alt></p><p>Vi velger eit pivotpoint, vi rearrangerer, vi velger eit nytt pivot point, vi rearrangerer, repiter til vi har ein subarray av element st√∏rrelse lavere enn 2. Sorter denne, det er jo berre √• sjekke kass av dei to som er st√∏rst og plassere riktig.</p><a href=#linear-time-partiotioning><h2 id=linear-time-partiotioning><span class=hanchor arialabel=Anchor># </span>Linear-time partiotioning.</h2></a><p>Det virkelige arbeidet av quicksort skjer i l√∏pet av divider steget, som partione $array[p..r]$ rundt eit pivot point dratt i fr√• subarrayen. Likevel vi kan velge kva enn som helst element i subarrayen som pivot pointet, er det enklest √• partione viss vi velger det h√∏gste index elementet av subarray $array[p..r]$.</p><p>Etter at vi har v√•rt pivot point kan vi partione subarrayen ved √• g√• gjennom den fr√• venstre til h√∏gre og samenligne kvart element med pivoten, har har to indices $q$ og $j$ in i subarrayen som dividerer den opp i $4$ grupper. Vi kan bruke variabeln $q$ fordi indexen vil eventuellt vere p√• v√•rt pivot point. Vi kan bruke $j$ fordi det er ein teller variabel og variabelen blir kastet vekk n√•r vi er ferdig.</p><ul><li>Alle elementer i $array[p..q-1]$ er gruppe &ldquo;L&rdquo;, som best√•r av elementer kjent til √• vere mindre eller lik til pivoten.</li><li>Alle elementer i subarrayen $array[q..j-1]$ er gruppe &ldquo;G&rdquo; som best√•r av elementer kjent til √• vere st√∏rre enn pivoten.</li><li>Elementer i subarray $array[j..r-1]$ er kjent som gruppe &ldquo;U&rdquo;, og best√•r av elementer som sitt forhold til pivtoen er ukjent, fordi dei har ikkje enda blitt compared.</li><li>$array[r]$ er gruppe &ldquo;P&rdquo;, pivot pointet.</li></ul><p>Originalt er b√•de $q$ og $j$ lik som $p$. Ved kvart steg, samanliknar vi $array[j]$, den mest venstre elementet i gruppe &ldquo;U&rdquo; med pivoten. Viss $array[j]$ er st√∏rre enn pivoten s√• $j++$, slik at linjen som dividerer gruppe &ldquo;G&rdquo; og gruppe &ldquo;U&rdquo; g√•r ein posisjon over til h√∏gre.
<img src=https://cdn.kastatic.org/ka-perseus-images/557d3afb93f7ba9abb3a9e845113fcf9ce1e56d8.png width=auto alt></p><p>N√•r vi kommer til pivoten s√• er gruppe &ldquo;U&rdquo; tom. Vi deretter swapper pivoten med den mest venstre elementet i gruppe &ldquo;G&rdquo;: swap $array[r]$ med $array[q]$. Dette plasserer pivoten mellom gruppene &ldquo;L&rdquo; og &ldquo;G&rdquo; og gjer den rette tingen til og med viss gruppe &ldquo;L&rdquo; eller gruppe &ldquo;G&rdquo; er tom.</p><p>Denne &ldquo;partition&rdquo; funksjonen som implementerer denne ideen returner og index $q$ der den endte opp med √• plassere pivoten, slik at $quicksort$ funksjonen, som blir kalt, veit kor partitionsene er.</p><p>Her er dei f√∏rste stegene i partione subarray $[12,7,14,9,10,11]$ i $array[4..9]$</p><p><img src=https://cdn.kastatic.org/ka-perseus-images/53692155715c9f26ec927cb2d40e70ce6c460e86.png width=auto alt></p><p>√Ö partionene ein subarray med $n$ element vil ta $\theta(n)$ tid. Kvart element $array[j]$ er compared ein gang med pivoten. $array[j]$ kanskje eller kanskje ikke blir swapper med $array[q]$, og $q$ kanskje eller kanskje ikkje blir inkrementert, og $j$ blir alltid inkrementert. Den totale nummeret av linjer executer per element av subarrayen er konstant. Siden subarrayen har $n$ vil den totale partition tiden vere $\theta(n)$: linear-time partioning.</p><a href=#analyse-av-quicksort><h1 id=analyse-av-quicksort><span class=hanchor arialabel=Anchor># </span>Analyse av quicksort.</h1></a><p>Satan fuck deg quicksort. ü§Ø.</p><p>Quicksort sin verse case sceneario og gjennomsnittleg scenario er forskjellig p√• grunn av metoden vi finner v√•rt pivot-point som lar oss redusere tidsbruken ganske mykje.
Viss vi er ganske uheldig og partition st√∏rrelse er j√¶vlig ubalansert, i vertste tilfelle der den eine er $0$ og den andre $n-1$ , alle utanom pivotpointet, s√• vil det vere <a class="internal-link broken">rekurisve tilkallinger p√• st√∏rrelser av n-1 og 0.</a>. Likt som i <a class="internal-link broken">Mergesort</a> er denne tidne det samme som $\theta(n)$ p√• ein array av st√∏rrelse $n$. I mergesort er det tiden for meging, men i quicksort er det <strong>berre</strong> tiden for partitioning.</p><a href=#verste-case-sceneario-running-time><h2 id=verste-case-sceneario-running-time><span class=hanchor arialabel=Anchor># </span>Verste-case sceneario running time.</h2></a><p>N√•r quicksort alltid har den mest ubalanserte partitionene mogleg s√• er den originale tilkallingen $cn$ tid for ein konstant av $c$, og der er $n-1$ rekurisve tilkallinger, den f√∏rste vil dermed vere $c(n-1)$ den neste $c(n-2)$ ‚Ä¶‚Ä¶ til det er $c(1)$. Slik vil denne subproblem grafen sj√• ut.
<img src=https://cdn.kastatic.org/ka-perseus-images/7da2ac32779bef669a6f05decb62f219a9132158.png width=auto alt></p><p>N√•r vi tar og adderer alle dei ulike running-timene vil det sj√• slik ut:
$cn+c(n-1)+c(n-2)‚Ä¶‚Ä¶+2c=c(n+(n-1)+(n-2)+(n-3)‚Ä¶‚Ä¶)=c((n+1)(\frac{n}{2})-1)$.
Den siste linjen $1+2+3‚Ä¶‚Ä¶‚Ä¶‚Ä¶+n$ er ein aritmetikk serier, og som vi s√•g n√•r vi analyserte <a class="internal-link broken">Selection sort.</a> (Vi subtraherer 1 fordi for quicksort, starter summasjonen p√• 2, og ikkje 1). Vi har nokre lavere order termer og konstante koeffisienter, men n√•r vi bruker <a class="internal-link broken">Big theta</a> notasjon s√• ignorer vi dem fordi dei er konstante verdier og lavere termer. I <a class="internal-link broken">Big theta</a> notasjon er quicksort sin verste kj√∏re tid $\theta(n^2)$.</p><a href=#beste-case-sceneario-running-time><h2 id=beste-case-sceneario-running-time><span class=hanchor arialabel=Anchor># </span>Beste-case sceneario running time.</h2></a><p>Quicksort sin beste case skjer n√•r partionene er s√• gjevnt som mogleg, der deirast sider er entens like eller med ein distanse av 1 i st√∏rrelse av kvarandre. Casen med ingen forskjell i forskjell skjer n√•r subarrayen har eit oddetall nummer av elementer og pivoten er rett i midten etter partionering, og kvart partition har $\huge \frac{n-1}{2}$ elementer. Den andre casen, skjer viss subarrayen har eit partall nummer av elementer og pivoten den eine siden/partionen har $\huge \frac{n}{2}$ elementer, mens den andre har $\huge \frac{n}{2}-1$ elementer. I kvar av disse casene har partionen p√• det meste $\huge \frac{n}{2}$ elementer, og dens tre/graf av subproblemene sine st√∏rrelse ser meir ut som treet for subproblemer i <a class="internal-link broken">Mergesort</a>, med dens partionerings tider liknande til merging tidene:
<img src=https://cdn.kastatic.org/ka-perseus-images/21cd0d70813845d67fbb11496458214f90ad7cb8.png width=auto alt></p><p>Vi bruker <a class="internal-link broken">Big theta</a> notasjon og f√•r det samme resultatet som for mergesort $\theta(n\times \log_2(n))$.</p><a href=#gjennomsnittleg-case-scenario-running-time><h2 id=gjennomsnittleg-case-scenario-running-time><span class=hanchor arialabel=Anchor># </span>Gjennomsnittleg-case scenario running-time.</h2></a><p>For √• vise at den gjennomsnittlege running timen er √≤g $\theta(n\times \log_2(n))$ krever det faktisk nokre ganske avansert matematikk s√• vi g√•r ikkje der. Men vi kan forst√• litt betre korleis denne algoritmen sin generelle kj√∏re tid er dersom vi ser p√• nokre ulike d√∏mer.</p><p>F√∏rst la oss forestille oss at vi ikkje alltid f√•r heilt perfekte balanserte partitionser, vi f√•r til d√∏mes p√• det verste ein split av $3$ til $1$. Det er betyr den eine siden f√•r $\frac{3}{4}\times n$ elementer, og den andre $\frac{1}{4} \times n$ elementer. (Vi ignorer pivot pointet her for √• holde matte ren, men den gjer at vi ikkje f√•r egentelig ein perfekt 3 til 1 split). Da vil treet av subproblemer og partition tidene se slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/130b2d2a1fe897253def054f4c3aa7bd94cb6cf2.png width=auto alt></p><p>Venstre childen av ein node representerer eit subproblem av st√∏rrelse $\frac{1}{4}$ av forrige, og childen til h√∏gre viser $\frac{3}{4}$ av forrige. Viss vi f√∏lger venstre sidene vil vi raskt minske ned til basecasen av $1$ fordi vi har mykje mindre elementer per iterasjon, mens derimot viss vi f√∏lger berre til h√∏gre vil vi mykje saktere komme til basecasen av $1$. Som figuren viser etter $\log_4(n)$ leveler kjemer vi ned til st√∏rrelsen av $1$ viss vi f√∏lger til venstre. Det er enklest √• forestille seg kvifor $\log_4(n)$ viss vi starter med $1$ og g√•r opp med $4\times$ om gangen til vi n√•r $n$. S√• i andre ord sp√∏r vi kva verdi av $x$ vi f√•r $4^x=n$, og svaret er jo da sj√∏lvsagt $\log_4(n)$. Derimot n√•r vi g√•r nedover til h√∏gre kvar iterasjon vil svaret vere $\log_\frac{4}{3}(n)$ til vi kommer ned til basecasen av $1$. For √• f√∏restille seg kvifor akkurat $\log_\frac{4}{3}(n)$ er det lett √• tenke at kvart barn er $\frac{3}{4}$ av den √∏vre noden sin st√∏rrelse, kvar √∏vre node er dermed $\frac{4}{3}$ av barnets st√∏rrelse. Viss vi dermed starter med ein basecase av $1$ og multiplserer med $\frac{4}{3}$ til vi n√•r $n$ s√• har vi multiplisert $\log_\frac{4}{3}(n)$ ganger.</p><p>Den verste runningtimen av $\log_4(n)$ og $\log_\frac{4}{3}(n)$ er $\log_\frac{4}{3}(n)$ s√• vi fokuserer berre p√• er $\log_\frac{4}{3}(n)$.For kvart av dei f√∏rste $\log_4(n)$ niv√•ene er det $n$ elementer (inkludert pivotpointer som i realiteten ikkje blir partionet.) og s√• den totale partition tiden er for kvar av disse niv√•ene berre $cn$ for ein konstant av $c$. Og dei siste niv√•ene har mindre enn $n$ noder og s√• for kvar av disse levelene er det p√• det meste $cn$ runningtime. Til sammen er det $\log_\frac{4}{3}(n)$ eveler, og s√• den totale partition tiden er $O(n \times \log_\frac{4}{3}(n))$.</p><p>Og det er eit matematisk bevis som nemner at $\log_a(n)=\frac{\log_b(n)}{\log_b(a)}$., som tyder at vi berre har ein konstant faktor mellom dei ulike tallene og vi kan egentelig berre bestemme kva enn som helst base vi √∏nsker √• ha n√•r vi noterer ned runningtimen. S√• vi pleier √• bruke $2$ for basen. Dermed er quicksort sin running time $O(\log_2(n))$, likevel vi faktisk har ein h√∏gere konstant faktor som er h√∏gere enn den beste case running timen.</p><p>Kor ofte vi burde forvente √• see ein split som er $3$ til $1$ eller betre? Det kjemer heilt ann p√• korleis vi velger v√•re pivot-points. Viss vi forestiller oss at pivotpintenhar ein like stor sjanse for √• lande p√• kva enn som helst index av ein $n$ elementer liste. Da m√• vi pivotpointen lande i midten av arrayen for √• oppn√• ein split som er $3$ til $1$ eller betre.
<img src=https://cdn.kastatic.org/ka-perseus-images/a77e296baf334b577328a5f15ab294a652ad6b96.png width=auto alt></p><p>S√• viss pivot-pointen har ein like stor sjanse for √• lande kor enn som helst i arrayen etter partitioning er det ein $50%$ sjanse for at vi f√•r p√• det verste ein split av $3$ til $1$.</p><p>Viss vi tar eit anna d√∏me og ser p√• d√∏met der vi f√•r ein alternerende split av $3$ til $1$ og den verste case scenario, og vi tenker p√• ein node i eit tre med $k$ elementer i dens subarray. Da vil treet sj√• slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/1f6a230039af38419453096c58bfd3ab5ac77b0f.png width=auto alt></p><p>I staden for √• sj√• slik ut:
<img src=https://cdn.kastatic.org/ka-perseus-images/656ca0d8ab950299dcc2800e6b2a52cc7ea6ffd5.png width=auto alt></p><p>Dermed viss vi f√•r den verste case splitten halvparten av tiden og ein split som $3$ til $1$ halvparten av tiden vil runningtimen vere dobbel s√• stor av det √• f√• ein runningtime av $3$ til $1$ kvar gang. Igjen s√• er dette berre ein konstant faktor som blir absorbert inn i <a class="internal-link broken">Big O</a> notasjonen, dermed er √≤g running timen i denne scenarioet $O(n\times \log_2(n))$.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://quartz.jzhao.xyz/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Are Olsen using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2022</p><ul><li><a href=https://quartz.jzhao.xyz/>Home</a></li><li><a href=https://simongobrrr.github.io>Are's Homepage</a></li><li><a href=https://github.com/SimonGoBrrr>Github</a></li></ul></footer></div></div></body></html>