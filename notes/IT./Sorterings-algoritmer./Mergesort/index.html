<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Merge sort - sorterings algoritmen. Merge sort er ein [[Rekurisve algoritmer.|rekursiv algortime]] basert på [[Divide and Conquer.]] teknikken, den sorterer ein array ganske enkelt."><title>Ares Notater</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://simongobrrr.github.io/AresNotater//icon.png><link href=https://simongobrrr.github.io/AresNotater/styles.706bb6073ba85d26809f9096dae23a6b.min.css rel=stylesheet><link href=https://simongobrrr.github.io/AresNotater/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://simongobrrr.github.io/AresNotater/js/darkmode.b4bb9713f905e029b1bca4cdcb9700da.min.js></script>
<script src=https://simongobrrr.github.io/AresNotater/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://simongobrrr.github.io/AresNotater/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://simongobrrr.github.io/AresNotater/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://simongobrrr.github.io/AresNotater/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://simongobrrr.github.io/AresNotater/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://simongobrrr.github.io/AresNotater/",fetchData=Promise.all([fetch("https://simongobrrr.github.io/AresNotater/indices/linkIndex.3650a1fb8b1d9417b70ace49f74a464d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://simongobrrr.github.io/AresNotater/indices/contentIndex.ac5547ba5cd8c91201eb686698296292.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://simongobrrr.github.io/AresNotater",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://simongobrrr.github.io/AresNotater",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/simongobrrr.github.io\/AresNotater\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://simongobrrr.github.io/AresNotater/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://simongobrrr.github.io/AresNotater/>Ares Notater</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Dec 3, 2022
<a href=https://github.com/SimonGoBrrr/AresNotater.github.io/notes/IT./Sorterings%20algoritmer./Mergesort.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#merge-to-subarrays-aka-linear-time-merging>Merge to subarrays, aka linear time merging.</a></li></ol></nav></details></aside><a href=#merge-sort---sorterings-algoritmen><h1 id=merge-sort---sorterings-algoritmen><span class=hanchor arialabel=Anchor># </span>Merge sort - sorterings algoritmen.</h1></a><p>Merge sort er ein <a class="internal-link broken">rekursiv algortime</a> basert på <a class="internal-link broken">Divide and Conquer.</a> teknikken, den sorterer ein array ganske enkelt.</p><p>Ved å bruke divide and conquer til å sortere trenger vi først å vite korleis våre subproblemer vil se ut som. Det fulle problemet er å sortere ein heil array så la oss si at vår subproblem er å sortere ein subarray. La oss starte subarrayen med index $p$ og slutte på index $r$. La oss gi arreyn ein notasjonen $array[p..r]$ . (Berre psuedocode). Originalt problem sorter : $array[0..n-1]$.</p><p>Merge sort teknikk:</p><ol><li>Divide ved å finne nummeret &ldquo;q&rdquo; ut av posisjonen midt mellom $p$ og $r$. Gjer dette likt som binary search, adder $p$ og $r$, divider med $2$, rund ned til nærast integer.</li><li>Conquer med å rekursivt sortere kvar subarray i kvar av dei to subproblemene/subarrayene, skapt av den originale divide steget. Sorter $array[p..q]$ og $array[q+1..r]$.</li><li>Combine ved å &ldquo;merge&rdquo; dei to ulike sortertere subarrayene tilbake til ein singel sortert array $array[p..r]$.</li></ol><p>Base case er subarrayen har to eller mindre elementer. Når $p\le r$ siden arrayen med null elementer eller berre ein er allerie sortert. Så dividerer og konkurerer berre når $p\lt r$. Steget av å dividerer og konkurere skjer rekurisvt - fleire ganger.</p><p>Vi tester ut eit eksempel:
Vi har ein $array[14, 7, 3, 12, 9, 11, 6, 2]$.
I første iterasjon er det heile arrayen vi driver med $p=0,r=7$. Denne arrayen er meir enn to elementer så det er ikkje ein basecase.</p><ol><li>I divide steget settjer vi $q=3$, $\lfloor \frac{7}{2}\rfloor = 3$.</li><li>I conquer steget sorterere vi arrayen mellom $array[0..3]$ og $array[4..7]$ .<ol><li>$array[0..3]$ blir over til $[3,7,12,14]$</li><li>$array[4..7]$ blir over til $[2,6,9,11]$.</li></ol></li><li>I combine steget drar vi disse to sorterte arrayene sammen. Slik at resultatet blir til slutt.<ol><li>Slik at $array[0..7]$ blir til $2,3,6,7,9,11,12,14$.</li></ol></li></ol><p>Måten vi sorterer dei to subarrayene skjer på samme metode vi divide og conquere den.
Så lenge dei ikkje er ein basecase.</p><p>Her er ein visualisering over korleis mergesort sortere denne arrayen.</p><p><img src=https://cdn.kastatic.org/ka-perseus-images/ace963383bea8d154f6abd1322a06a73b56b4628.png width=auto alt></p><p>Dei fleste stegene i mergesort er ganske lette, vi kan lett dividere, og ganske lett finne midpointet. Den vanskelege delen er å merge dei ulike subarrayene når det trengst.</p><a href=#merge-to-subarrays-aka-linear-time-merging><h2 id=merge-to-subarrays-aka-linear-time-merging><span class=hanchor arialabel=Anchor># </span>Merge to subarrays, aka linear time merging.</h2></a><p>Den igjenstående delen av mergesort er å merge subarrayer.
Å merge to subarrayer kan vi gjere i linear-time som tyder den har ein $\theta(n)$.</p><p>Det første vi gjer å kopiere dei ulike subarrayene inn i nye variabeler slik at vi kan tulle med subarrayene for å merge dei sammen.</p><p>Først:</p><ol><li>Alloker to midlertidige arrayer: laveHalve, høgeHalve.</li><li>Kopier $array[p..q]$ inn i laveHalve, og $array[q+1..r]$ inn i høgeHalve.<ol><li>I vårt tidligere eksempel tyder dette av laveHalve har ein verdi av $[3,7,12,14]$ og høgeHalve $[2,6,9,11]$.</li></ol></li><li>Så merger vi dei!<ol><li>Vi itererer over antallet elementer som skal vere</li><li>Vi tar den minste verdien av index $i$ på laveHalve og index $j$ på høgeHalve og settjer den minste inn i vår aktuelle nye array.</li></ol></li></ol><a href=#analyse-av-mergesort><h1 id=analyse-av-mergesort><span class=hanchor arialabel=Anchor># </span>Analyse av mergesort.</h1></a><p>Me veit at merge funksjonen kjører i $\theta(n)$ når vi merger $n$ elementer, men kvifor er da mergeSort i $\theta(n\times \log_2(n))$. Vi kan starte ved å sjå på runningtimen til dei tre ulike stegene i <a class="internal-link broken">Divide and Conquer.</a>. Vi ser litt nærmere:</p><ol><li>Divide - divider steget tar ein konstant tid, uansett kva størrelsen av subarrayen er. Etter alt så er det einaste divider steget gjer å komputere midpunkt verdien $q$ av indexene $p$ og $r$. I <a class="internal-link broken">Big theta</a> indikerer vi ein konstant tid av $\theta(1)$.</li><li>I conquer steget gjer vi ein rekursiv sorterting av to subbarrays av omtrent $\frac{n}{2}$ elementer. Det tar litt tid, men vi tar hensyn til den tiden når vi holder på med subproblemene.</li><li>Når vi merger eit totalt av $n$ elementer gjennom vår merge funksjon tar det $\theta(n)$</li></ol><p>Når vi tenker på divider og kombiner stegene sammen, vil den $\theta(1)$ running-timen for divider steget vere ein lav order term i forhold til $\theta(n)$ av running-timen til kombiner steget. Så la oss tenke at divider og kombiner stegene sin running time kombinert er $\theta(n)$. Litt meir konkret tar dei ein total running-time av $c\times n$ for ein eller anna konstant verdi av $c$.</p><p>Viss vi halder det simpelt og sier at viss $n\lt1$ da er $n$ alltid eit partall, så det gjer at vi kan tenke at $\frac{n}{2}$ er òg ein integer. (Og partall). Tilfellet der $n$ er eit oddetall skifter ikkje <a class="internal-link broken">Big Theta</a> av funksjonen. Så vi kan tenke at runnningtimen for mergeSort er summen av of 2 gange runningtimen av mergeSort på ein subarray av $\frac{n}{2}$ størrelse (for conquer seget), $+cn$. (for divide and combine stegene).</p><p>Nå må vi finne ut runningtimen av to rekursive tilkalling på $\frac{n}{2}$ elementer. kvar av disser rekursive tilkallingene tar dobbelt så lang tid av running timen av mergeSort på ein array av $\frac{n}{4}$ størrelse (vi halverer $\frac{n}{2}$ blir til $\frac{n}{4}$), plus $\frac{cn}{2}$ til å merge. VI dermed har to subproblemer av størrelse $\frac{n}{2}$ som begge tar $\frac{cn}{2}$ tid til å merge. Så vi kan sie at den totale tiden for å merge alle subproblemene hittil av størrelse $\frac{n}{2}$ er det same som $\frac{cn}{2}\times 2$.</p><p>Vi kanteikne ut merging tidene i eit tre.
<img src=https://cdn.kastatic.org/ka-perseus-images/808e1b1b992aef56270b3fc2b9ecc1a68eba8988.png width=auto alt></p><p>Informatikk vitskapsmenn teikner trer oppned frå korleis trer normalt vokser. Eit tre er ein graf utan nokon sykluser (sykluser er veger som starte og slutte på samme sted). Dei ulike delene av eit kaller vi for treets nodes. Root node-n er på toppen, her er root-noden merket med $n$ for arrayen sin originale størrelse. Under finner vi nodesene som har ein subarray størrelse av $\frac{n}{2}$.</p><p>kvart av subproblemene av størrelse $\frac{n}{2}$ rekursivt sorterer to subarrayer av størrelse $\frac{n}{4}$. Fordi vi har to subproblemer av størrelse $\frac{n}{2}$ så har vi fire subproblemer av størrelse $\frac{n}{4}$.
Og merge tiden for kvar av disse subproblemene av størrelse $\frac{n}{4}$ er det samme som $\frac{cn}{4}$ og summert blir dei til saman $4\times \frac{cn}{4}=cn$.</p><p><img src=https://cdn.kastatic.org/ka-perseus-images/6a59f0e9973778cd9a157d8f92d5301dcf619417.png width=auto alt></p><p>Vi fortsetter slik heilt til $n<mark>1 || n</mark>0$ . Etter hvert som subproblemene blir mindre blir nummeret av subproblmer dobblet kvar gang det går ein iterasjon nedover i rekursjonen. Dobblingen og halvering kanselerer seg ut og gjer at vi får ein total merging time kvar gang av $cn$. Til slutt kjemer vi til base casen, der $n==1$, og fordi vi om vi er komt til base casen eller ikkje gjennom $p\le r$ så tar dette litt tid. Kor mange subarrayer av størrelse 1 er det. Siden vi starter med ein array av størrelse $n$ så gjer det at vi ein mengde $n$ subproblemer med ein størrelse av subarray 1. SIden kvar basecase tar tid $\theta(1)$ så kan vi si at alle base casene tar til sammen $cn$ tid.
<img src=https://cdn.kastatic.org/ka-perseus-images/5fcbebf66560d8fc490de2a0d8a0e5b1d65c5c54.png width=auto alt></p><p>Nå som vi veit kor lang tid merging tar for kvart subproblem. Den totale tiden for mergeSort til å kjøre er den totale mengden merging tider for alle levelene. Viss det er $l$ leveler i treet så er tiden $l\times cn$. Viss vi skal finne ut kva $l$ er så må vi så på korleis vi går nedover, kvar gang vi går nedover så halverer vi i størrelse, nett likt som vi gjer når vi har binary-search, derfor kan vi si at tiden er $l=log_2(n)+1$, akkurat som i binary search. Siden 1 er eit uviktig tall så kan vi ignorere denne når det kjemer til den endelige running tiden, i tillegg fordi $c$ er konstant så kan vi òg ignorere denne.
Dette gjer at vår running time dermed er $\theta(n\times \log_2(n))$.</p><p>Ein anna ting om mergeSort som er viktig å legge merke til, den tar å kopierer ein kopi of heile mens den blir sortert, med den eine delen i lowHalf og den eine delen i highhalf. Fordi den kopierer meir enn ein konstant nummer av elementer samtidig, så sier vi at mergeSort jobber ikkje &ldquo;in place&rdquo;. derimot både <a class="internal-link broken">Selection sort.</a> og <a class="internal-link broken">Insertion sort.</a> jobbe in place, siden dei aldri lager ein kopi av ein størrelse som ikkje er konstant. Fordi nokre systemer er det ikkje stor mengde fri plass av memory så liker vi ofte å ta dette i hensyn og bruke heller in-place algoritmer når dette er scenearioet.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://simongobrrr.github.io/AresNotater/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Are Olsen using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://simongobrrr.github.io/AresNotater/>Home</a></li><li><a href=https://simongobrrr.github.io>Are's Homepage</a></li><li><a href=https://github.com/SimonGoBrrr>Github</a></li></ul></footer></div></div></body></html>